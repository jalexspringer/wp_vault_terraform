#+TITLE: Flux7 Vault Presentation
#+AUTHOR: Alex Springer
* Introduction
Walking through creating a highly available Wordpress blog using AWS and
Terraform. We'll then ensure high security by leveraging the power of Hashicorp
Vault to centralize control and auditing of secrets and access rights.

** Why use Vault?
- Dynamic generation of AWS access credentials based on IAM policies defined and
  maintained via Terraform (Ifrastructure as Code practices)
- Smaller attack surface - all secret are managed and distributed as needed with
  a defined TTL to the various components of the application
- Microservices friendly 'break glass' policies - respond to security breaches
  in a targeted fashion that locks down only the affected parts of the system,
  leading to higher durability and shorter recovery time
- Full audit trail of all access and secret usage combined with easy to define
  TTL to ensure correct access for all users
- Simple encryption API for sensitive user/customer data

* Config
** Development Machine Setup
*** Tools
- Python 3.7.2
- Terraform v0.11.11
- ansible 2.7.7
*** SSH
#+BEGIN_SRC bash
ssh-keygen
ssh-agent bash
ssh-add ~/.ssh/cloudbase
#+END_SRC
** AWS Setup
- New User: cloudbase
#+BEGIN_SRC bash
aws configure --profile cb
#+END_SRC

*** Configure Route53
atcloudbase.net
- Get Route53 re-usable delegation set
  #+BEGIN_SRC bash
aws route53 create-reusable-delegation-set --caller-reference 1224 --profile cb
  #+END_SRC

  #+RESULTS:
  | Location        | https://route53.amazonaws.com/2013-04-01/delegationset/N2WOUDW0QCOUSM |
  | DelegationSet   |                                                                       |
  | Id              | /delegationset/N2WOUDW0QCOUSM                                         |
  | CallerReference | 1224                                                                  |
  | NameServers     |                                                                       |
  |                 | ns-778.awsdns-33.net                                                  |
  |                 | ns-1637.awsdns-12.co.uk                                               |
  |                 | ns-1071.awsdns-05.org                                                 |
  |                 | ns-343.awsdns-42.com                                                  |

- Update nameservers for atcloudbase.net

* Terraforming
:PROPERTIES:
:header-args: :padline no :results raw
:END:

Directory/file structure
#+BEGIN_SRC bash
# Terraform files
touch main.tf variables.tf terraform.tfvars vpc.tf iam.tf
# Ansible and AWS files
touch userdata aws_hosts wordpress.yml s3update.yml
#+END_SRC

Keeping secrets from git
#+BEGIN_SRC bash :tangle .gitignore
*.tfvars
credentials.csv
.terraform
*.plan
#+END_SRC

** Region and profile setup:
#+BEGIN_SRC bash :tangle terraform.tfvars
aws_profile = "cb"
aws_region  = "us-east-1"
#+END_SRC

#+BEGIN_SRC bash :tangle config.tf
provider "aws" {
  region  = "${var.aws_region}"
  profile = "${var.aws_profile}"
}
#+END_SRC

#+BEGIN_SRC bash :tangle variables.tf
variable "aws_region"  {}
variable "aws_profile" {}
#+END_SRC

** Initialize Terraform
#+BEGIN_SRC bash :results raw
terraform init
#+END_SRC

#+BEGIN_SRC bash :results raw :tangle no
terraform plan -no-color
#+END_SRC

#+RESULTS:
[0m[1mRefreshing Terraform state in-memory prior to plan...[0m
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.
[0m

------------------------------------------------------------------------

[0m[1m[32mNo changes. Infrastructure is up-to-date.[0m[32m

This means that Terraform did not detect any differences between your
configuration and real physical resources that exist. As a result, no
actions need to be performed.[0m

** IAM Access Roles (s3)
:PROPERTIES:
:header-args: :tangle iam.tf
:END:
#+BEGIN_SRC bash
#----- IAM -----

#S3_access
resource "aws_iam_instance_profile" "s3_access_profile" {
  name = "s3_access"
  role = "${aws_iam_role.s3_access_role.name}"
}

resource "aws_iam_role_policy" "s3_access_policy" {
  name = "s3_access_policy"
  role = "${aws_iam_role.s3_access_role.id}"

  policy = <<EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "s3:*",
      "Resource": "*"
      }
    ]
  }
EOF
}


resource "aws_iam_role" "s3_access_role" {
  name = "s3_access_role"

  assume_role_policy = <<EOF
{
  "Version": "2012-10-17",
  "Statement": [
      {
        "Action": "sts:AssumeRole",
        "Principal": {
          "Service": "ec2.amazonaws.com"
          },
        "Effect": "Allow",
        "Sid": ""
      }
    ]
  }
EOF
}
#+END_SRC

#+BEGIN_SRC bash :results raw :tangle no
terraform plan -no-color
#+END_SRC

#+RESULTS:
Refreshing Terraform state in-memory prior to plan...
The refreshed state will be used to calculate this plan, but will not be
persisted to local or remote state storage.


------------------------------------------------------------------------

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

+ aws_iam_instance_profile.s3_access_profile
      id:                    <computed>
      arn:                   <computed>
      create_date:           <computed>
      name:                  "s3_access"
      path:                  "/"
      role:                  "s3_access_role"
      roles.#:               <computed>
      unique_id:             <computed>

  + aws_iam_role.s3_access_role
      id:                    <computed>
      arn:                   <computed>
      assume_role_policy:    "{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n      {\n        \"Action\": \"sts:AssumeRole\",\n        \"Principal\": {\n          \"Service\": \"ec2.amazonaws.com\"\n          },\n        \"Effect\": \"Allow\",\n        \"Sid\": \"\"\n      }\n    ]\n  }\n"
      create_date:           <computed>
      force_detach_policies: "false"
      max_session_duration:  "3600"
      name:                  "s3_access_role"
      path:                  "/"
      unique_id:             <computed>

  + aws_iam_role_policy.s3_access_policy
      id:                    <computed>
      name:                  "s3_access_policy"
      policy:                "{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"s3:*\",\n      \"Resource\": \"*\"\n      }\n    ]\n  }\n"
      role:                  "${aws_iam_role.s3_access_role.id}"
Plan: 3 to add, 0 to change, 0 to destroy.

------------------------------------------------------------------------

Note: You didn't specify an "-out" parameter to save this plan, so Terraform
can't guarantee that exactly these actions will be performed if
"terraform apply" is subsequently run.

** Create the VPC
:PROPERTIES:
:header-args: :padline no :results raw :tangle vpc.tf
:END:
*** VPC Setup
Define the VPC resource, references CIDR block variable
#+BEGIN_SRC bash
#----- VPC ------

resource "aws_vpc" "wp_vpc" {
  cidr_block           = "${var.vpc_cidr}"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags {
    Name = "wp_vpc"
  }
}
#+END_SRC

Define the CIDR block variable in terraform.tfvars and variables.tf
#+BEGIN_SRC bash :tangle terraform.tfvars
vpc_cidr = "10.0.0.0/16"
#+END_SRC
#+BEGIN_SRC bash :tangle variables.tf :padline no
variable "vpc_cidr" {}
#+END_SRC

*** Internet Gateway
#+BEGIN_SRC bash

# Internet Gateway
resource "aws_internet_gateway" "wp_internet_gateway" {
  vpc_id = "${aws_vpc.wp_vpc.id}"

  tags {
    Name = "wp_igw"
  }
}

#+END_SRC

*** Route Tables
#+BEGIN_SRC bash

# Route Tables
resource "aws_route_table" "wp_public_rt" {
  vpc_id = "${aws_vpc.wp_vpc.id}"

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = "${aws_internet_gateway.wp_internet_gateway.id}"
  }

  tags {
    Name = "wp_public"
  }
}

resource "aws_default_route_table" "wp_private_rt" {
  default_route_table_id = "${aws_vpc.wp_vpc.default_route_table_id}"

  tags {
    Name = "wp_private"
  }
}
#+END_SRC

*** Subnets
Gather the availability zone information and create cidr blocks array
#+BEGIN_SRC bash :tangle terraform.tfvars
cidrs = {
  public1  = "10.0.1.0/24"
  public2  = "10.0.2.0/24"
  private1 = "10.0.3.0/24"
  private2 = "10.0.4.0/24"
  rds1     = "10.0.5.0/24"
  rds2     = "10.0.6.0/24"
  rds3     = "10.0.7.0/24"
}
#+END_SRC

#+BEGIN_SRC bash :tangle variables.tf
data "aws_availability_zones" "available" {}
variable "cidrs" {
  type = "map"
}
#+END_SRC

#+BEGIN_SRC bash
# Subnets
# Public subnets
resource "aws_subnet" "wp_public1_subnet" {
  vpc_id = "${aws_vpc.wp_vpc.id}"
  cidr_block = "${var.cidrs["public1"]}"
  map_public_ip_on_launch = true
  availability_zone = "${data.aws_availability_zones.available.names[0]}"

  tags {
    Name = "wp_public1"
  }
}

resource "aws_subnet" "wp_public2_subnet" {
  vpc_id = "${aws_vpc.wp_vpc.id}"
  cidr_block = "${var.cidrs["public2"]}"
  map_public_ip_on_launch = true
  availability_zone = "${data.aws_availability_zones.available.names[1]}"

  tags {
    Name = "wp_public2"
  }
}

# Private Subnets
resource "aws_subnet" "wp_private1_subnet" {
  vpc_id = "${aws_vpc.wp_vpc.id}"
  cidr_block = "${var.cidrs["private1"]}"
  map_public_ip_on_launch = false
  availability_zone = "${data.aws_availability_zones.available.names[0]}"

  tags {
    Name = "wp_private1"
  }
}

resource "aws_subnet" "wp_private2_subnet" {
  vpc_id = "${aws_vpc.wp_vpc.id}"
  cidr_block = "${var.cidrs["private2"]}"
  map_public_ip_on_launch = false
  availability_zone = "${data.aws_availability_zones.available.names[1]}"

  tags {
    Name = "wp_private2"
  }
}

# RDS Subnets
resource "aws_subnet" "wp_rds1_subnet" {
  vpc_id = "${aws_vpc.wp_vpc.id}"
  cidr_block = "${var.cidrs["rds1"]}"
  map_public_ip_on_launch = false
  availability_zone = "${data.aws_availability_zones.available.names[0]}"

  tags {
    Name = "wp_rds1"
  }
}

resource "aws_subnet" "wp_rds2_subnet" {
  vpc_id = "${aws_vpc.wp_vpc.id}"
  cidr_block = "${var.cidrs["rds2"]}"
  map_public_ip_on_launch = false
  availability_zone = "${data.aws_availability_zones.available.names[1]}"

  tags {
    Name = "wp_rds2"
  }
}

resource "aws_subnet" "wp_rds3_subnet" {
  vpc_id = "${aws_vpc.wp_vpc.id}"
  cidr_block = "${var.cidrs["rds3"]}"
  map_public_ip_on_launch = false
  availability_zone = "${data.aws_availability_zones.available.names[2]}"

  tags {
    Name = "wp_rds3"
  }
}
#+END_SRC

*** Subnet Groups
#+BEGIN_SRC bash
# RDS Subnet Group

resource "aws_db_subnet_group" "wp_rds_subnetgroup" {
  name = "wp_rds_subnet_group"

  subnet_ids = [
    "${aws_subnet.wp_rds1_subnet.id}",
    "${aws_subnet.wp_rds2_subnet.id}",
    "${aws_subnet.wp_rds3_subnet.id}"
  ]

  tags {
    Name = "wp_rds_sng"
  }
}
#+END_SRC
